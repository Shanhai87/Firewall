/**
 * @file utils.h
 * @author lpuddy (tenochtitlan2010@yandex.ru)
 * @brief Заголовочный файл с описанием общих функций и структур для программ
 * firewall и generator
 * @version 1.0
 * @date май-июнь 2024 года
 * @warning Данная порграмма создана в учебных целях
 * @copyright Copyright (c) 2024
 */
#ifndef SRC_UTILS_H_
#define SRC_UTILS_H_

/**
 * @brief Позволяет использовать функции, которые не являются частью
 * стандарной библиотеки C, но являются частью стандарта POSIX.1-2017
 */
#define _POSIX_C_SOURCE 200809L

#include <ctype.h>  ///<Для использования некоторых стандартных функций.
#include <stdio.h>  ///<Для печати в канал вывода и работы с файлами.
#include <stdlib.h>  ///<Для динамического выделения памяти.
#include <string.h>  ///<Для использования стандартных функций, работающих со строками.
#include <sys/stat.h>  ///<Для проверки файлов.
#include <unistd.h>    ///<Для использования ssize_t.

/**
 * @warning новые протоколы добавить здесь
 */
enum protocol { IGMP = 2, TCP = 6, UDP = 17 };

/**
 * @brief         Структура для хранения параметров ip адреса.
 * Например, для адреса 10.11.12.13/14:
 * part = [10, 11, 12, 13],
 * mask = 14,
 * диапазон адресов 10.8.0.0 - 10.11.255.255,
 * min = 168296448,
 * max = 168558591.
 * @param part    Массив, хранящий 4 числа ip адреса.
 * @param mask    Маска подсети.
 * @param min     Минимальное значение ip адреса, преобразованное в десятичное
 * число.
 * @param max     Максимальное значение ip адреса, преобразованное в десятичное
 * число.
 */
typedef struct s_ip {
  int part[4];  ///<-- Массив, хранящий 4 числа ip адреса.
  int mask;     ///<-- Маска подсети.
  ssize_t min;  ///<-- Минимальное значение ip адреса.
  ssize_t max;  ///<-- Максимальное значение ip адреса.
} t_ip;

/**
 * @brief         Структура элемента списка (ноды).
 * @param content Указатель на сохраненную информацию.
 * @param next    Указатель на следующий элемент списка.
 */
typedef struct s_list {
  void *content;  ///<-- Указатель на сохраненную информацию.
  struct s_list *next;  ///<-- Указатель на следующий элемент списка.
} t_list;

/**
 * @brief           Добавить новый элемент в конец списка.
 * @param begin     Начало списка.
 * @param new_node  Новый элемент списка.
 */
void ft_lstadd_back(t_list **begin, t_list *new_node);

/**
 * @brief           Добавить новый элемент в начало списка.
 * @param begin     Начало списка.
 * @param new_node  Новый элемент списка.
 */
void ft_lstadd_front(t_list **begin, t_list *new_node);

/**
 * @brief           Удалить элемент из начала списка.
 * @param begin     Начало списка.
 * @param del       Указатель на функцию, применяемую к информации, хранящейся в
 * списке (функция должна соответствовать указанному прототипу, может быть
 * NULL).
 */
void ft_lstdel_front(t_list **begin, void (*del)(void *));

/**
 * @brief           Удалить элемент из списка по индексу.
 * @param begin     Начало списка.
 * @param del       Указатель на функцию, применяемую к информации, хранящейся в
 * списке (функция должна соответствовать указанному прототипу, может быть
 * NULL).
 * @param index     Индекс элемента в списке, счет начинается с 1.
 */
void ft_lstdel(t_list **begin, void (*del)(void *), size_t index);

/**
 * @brief           Создать новый элемент списка (ноду).
 * @param content   Указатель на сохраненную информацию.
 * @return t_list*  Указатель на созданную ноду.
 */
t_list *ft_lstnew(void *content);

/**
 * @brief     Удалить элемент списка (ноду).
 * @param lst Указатель на удаляемую ноду.
 * @param del Указатель на функцию, применяемую к информации, хранящейся в ноде
 * (функция должна соответствовать указанному прототипу, может быть NULL).
 */
void ft_lstdelone(t_list *lst, void (*del)(void *));

/**
 * @brief       Удалить список.
 * @param begin Начало списка.
 * @param del   Указатель на функцию, применяемую к информации, хранящейся в
 * списке (функция должна соответствовать указанному прототипу, может быть
 * NULL).
 */
void ft_lstclear(t_list **begin, void (*del)(void *));

/**
 * @brief         Получить размер списка.
 * @param begin   Начало списка.
 * @return size_t - Размер списка.
 */
size_t ft_lstsize(t_list *begin);

/**
 * @brief         Получить элемент списка по индексу.
 * @param begin   Начало списка.
 * @param index   Индекс элемента в списке, счет начинается с 1.
 * @return t_list * - Указатель на элемент списка.
 */
t_list *ft_lstget(t_list *begin, size_t index);

/**
 * @brief           Напечатать текст ошибки.
 * @param str       Текст ошибки.
 * @return int    - Код ошибки (1)
 */
int print_error(char *str);

/**
 * @brief           Проверить и открыть файл на чтение.
 * @param path      Путь к файлу (абсолютный или относительный).
 */
int is_file(const char *path);

/**
 * @brief           Проверить и открыть файл на чтение.
 * @param filename  Название файла.
 * @return FILE*  - Указатель на поток, связанный с открытым на чтение файлом.
 */
FILE *open_file(const char *filename);

/**
 * @brief      Освободить память у массива строк, полученного как результат
 * функции str_split.
 * @param str  Указатель на массив строк.
 */
void str_free_after_split(char **str);

/**
 * @brief        Получить из строки массив подстрок, разделенных
 * строкой-разделителем. Последняя строка массива всегда NULL.
 * @param str    Исходная строка.
 * @param delim  Разделитель (делимитер). Если NULL, то строка разрезается
 * пробельными символами.
 * @return char** - Указатель на массив строк.
 */
char **str_split(const char *str, char *delim);

/**
 * @brief        Проверить, состоит ли строка только из пробельных символов.
 * @param str    Проверяемая строка, не должна быть NULL.
 * @return int   (1 - строка содержит только пробельные символы (или пустая);
 * 2 - в строке есть непробельные символы).
 */
int str_isspace(char *str);

/**
 * @brief        Посчитать количество строк в массиве (последний элемент должен
 * быть NULL).
 * @param str    Указатель на массив строк.
 * @return int - Количество строк в массиве.
 */
int str_count_args(char **str);

/**
 * @brief        Преобразовать строку в беззнаковое целое число.
 * @param str    Исходная строка.
 * @return int - Число ("23" => 23), в случае некорректной строки возвращается
 * значение -1;
 */
int str_get_int(char *str);

/**
 * @brief        Преобразовать ip адрес в десятичное число.
 * @param part   Массив, состоящий из 4х чисел ip адреса.
 * @return size_t - Значение ip адреса в десятичном виде.
 */
size_t convert_ip_to_number(int *part);

/**
 * @brief        Вычислить минимальное и максильное значение ip адресов в
 * десятичном виде с сохранением в структуру.
 * @param ip     Указатель на структуру ip адреса.
 */
void calculate_min_max_ip(t_ip *ip);

/**
 * @brief        Создать новый объект ip адреса.
 * @return t_ip * - Указатель на созданный объект структуры.
 */
t_ip *create_ip();

/**
 * @brief        Получить значение маски подсети из строки.
 * @param str    Строка, в которой возможно указана маска.
 * @return int - Значение маски (32 - по умолчанию, если ее в строке нет; -1 -
 * если некорректное выражение; иначе - число от 0 до 32).
 */
int get_ip_mask(char *str);

#endif  // SRC_UTILS_H_